### C++ Day5 
#### 1. 복사 생성자
* 자신과 동일한 타입의 객체로 초기화 될때 사용되는 생성자
* 디폴트 복사 생성자: 사용자가 만들지 않으면 컴파일러가 제공
* 컴파일러가 만든 복사 생성자 모양
    * Point(const Point& pt) : x(pt.x), y(pt.y) {}
    * 모든 멤버를 복사해 줌
* 얕은 복사 (Shallow Copy): 
    * 클래스가 내부적으로 포인터 멤버가 있고 동적 메모리 할당했을 때,
    * 메모리 자체를 복사하지 않고 주소만 복사하는 현상
* 얕은 복사 해결: 사용자가 복사 생성자를 만들어서 해결해야 함
    * 포인터 멤버는 주소를 복사하지 말고 메모리 할당 후 메모리 자체를 복사 (깊은 복사)


#### 2. 예외
* C언어의 에러 처리 방법: 함수 반환값으로 실패로 약속된 값 반환
    * 반환 값과 실패의 전달이 분리되지 않음
    * 호출자가 실패를 무시할 수 있음 => 실패를 무시하면 더욱 큰 문제가 생길 수 있음
* 객체지향 언어의 "예외 문법"
    * 함수가 실패하면 예외를 던진다 (throw)
    * 예외 가능성이 있는 함수 호출 시 try{} 안에서 호출
    * catch에서는 실패의 이유를 확인하고 오류 수정
        * 오류 수정이 어려우면 사용자에게 알리고 std::exit() 등으로 종료  
    * 에러 시 int를 throw하지 말고 에러 전용 타입을 설계하여 throw 
* 장점
    * 반환 값과 실패의 전달이 완벽히 분리됨
    * 호출자는 던져진 예외를 반드시 처리해야 함 => 처리되지 않으면 비정상 종료함
* 단점
    * 코드가 복잡해지고 성능 저하의 원인이 됨

#### explicit
* explicit 생성자는 직접 초기화만 사용가능하고 복사 초기화는 에러!
    * Vector v1(10);	// 직접(direct) 초기화
    * Vector v2 = 10; // 복사(copy) 초기화. 함수에 인자를 전달하는 것은 복사 초기화

#### 3. STL 컨테이너
* vector: 연속된 메모리, v 자체는 stack이지만 데이터는 힙에 보관. 크기 변경 가능
    * 장점: 모든 요소의 순환이 빠름
    * 단점: 중간에 삽입/삭제가 느림
* list: 모든 요소가 떨어진 메모리 사용
    * 장점: 삽입/삭제가 빠름
    * 단점: 요소 순환이 느림 
* dequeue: list와 vector의 혼합 형태
    * 각 기능이 중간 정도의 성능
* 1. 대부분의 멤버 함수는 이름이 동일
* 2. 사용법이 다르면 의도적인 설계
* 3. [ ] 연산자는 vector와 deque만 가능
* 4. 대부분의 멤버 함수이름이 유사하므로 컨테이너를 변경해가면서 성능 테스트 할수 있음
* 제거와 반환을 동시에 하는 멤버 함수는 없

#### 4. 반복자

#### 5. 알고리즘

#### 6. 임시객체
