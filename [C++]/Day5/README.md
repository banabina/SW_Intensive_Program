### C++ Day5 
#### 1. 복사 생성자
* 자신과 동일한 타입의 객체로 초기화 될때 사용되는 생성자
* 디폴트 복사 생성자: 사용자가 만들지 않으면 컴파일러가 제공
* 컴파일러가 만든 복사 생성자 모양
    * Point(const Point& pt) : x(pt.x), y(pt.y) {}
    * 모든 멤버를 복사해 줌
* 얕은 복사 (Shallow Copy): 
    * 클래스가 내부적으로 포인터 멤버가 있고 동적 메모리 할당했을 때,
    * 메모리 자체를 복사하지 않고 주소만 복사하는 현상
* 얕은 복사 해결: 사용자가 복사 생성자를 만들어서 해결해야 함
    * 포인터 멤버는 주소를 복사하지 말고 메모리 할당 후 메모리 자체를 복사 (깊은 복사)


#### 2. 예외
* C언어의 에러 처리 방법: 함수 반환값으로 실패로 약속된 값 반환
    * 반환 값과 실패의 전달이 분리되지 않음
    * 호출자가 실패를 무시할 수 있음 => 실패를 무시하면 더욱 큰 문제가 생길 수 있음
* 객체지향 언어의 "예외 문법"
    * 함수가 실패하면 예외를 던진다 (throw)
    * 예외 가능성이 있는 함수 호출 시 try{} 안에서 호출
    * catch에서는 실패의 이유를 확인하고 오류 수정
        * 오류 수정이 어려우면 사용자에게 알리고 std::exit() 등으로 종료  
    * 에러 시 int를 throw하지 말고 에러 전용 타입을 설계하여 throw 
* 장점
    * 반환 값과 실패의 전달이 완벽히 분리됨
    * 호출자는 던져진 예외를 반드시 처리해야 함 => 처리되지 않으면 비정상 종료함
* 단점
    * 코드가 복잡해지고 성능 저하의 원인이 됨

#### explicit
* explicit 생성자는 직접 초기화만 사용가능하고 복사 초기화는 에러!
    * Vector v1(10);	// 직접(direct) 초기화
    * Vector v2 = 10; // 복사(copy) 초기화. 함수에 인자를 전달하는 것은 복사 초기화

#### 3. STL 컨테이너
* vector: 연속된 메모리, v 자체는 stack이지만 데이터는 힙에 보관. 크기 변경 가능
    * 장점: 모든 요소의 순환이 빠름
    * 단점: 중간에 삽입/삭제가 느림
* list: 모든 요소가 떨어진 메모리 사용
    * 장점: 삽입/삭제가 빠름
    * 단점: 요소 순환이 느림 
* dequeue: list와 vector의 혼합 형태
    * 각 기능이 중간 정도의 성능
* 1. 대부분의 멤버 함수는 이름이 동일
* 2. 사용법이 다르면 의도적인 설계
* 3. [] 연산자는 vector와 deque만 가능
* 4. 대부분의 멤버 함수이름이 유사하므로 컨테이너를 변경해가면서 성능 테스트 할수 있음
* 제거와 반환을 동시에 하는 멤버 함수는 없

#### 4. 반복자
* 반복자(iterator): 컨테이너의 모든 요소를 열거할 때 사용하는 객체
   * C++에서는 포인터처럼 사용할 수 있도록 연산자 재정의되어 있음
* 반복자는 정확한 타입이 있지만 auto를 사용하는 것을 권장
   * 정확한 타입을 표기하면, 코드가 복잡해 보이고 컨테이너 변경 시 코드 변경해야 함
* auto p2 = s.end(); => 마지막 요소가 아닌 마지막 다음을 의미
* 컨테이너 모든 요소 열거하는 방법
* 1. range - for 문, 모든 컨테이너 가능, C++11부터. 전체 열거만 가능

```cpp
for (auto e : c)
{
   std::cout << e << std::endl;
}
```

* 2. 반복자 사용, 모든 컨테이너 가능
```cpp
auto p1 = c.begin();
auto p2 = std::next(p1, 4); // p1의 4칸 뒤 반복자 얻기
while (p1 != p2)
{
   std::cout << *p1 << std::endl;
   ++p1;
}
```

* 3. [] 연산자 사용 - vector, deque만 가능, list 안됨
```cpp
for (int i = 0; i < c.size(); ++i)
{
   c[i] = 0;
}
```

* 역반복자(reverse iterator): 역방향으로 모든 요소를 열거할 때 사용
   * rbegin(), rend()
* auto p1 = std::begin(s) 진짜 배열인 경우에도 반복자 꺼낼 수 있음

#### 5. 알고리즘
* STL에서 알고리즘: std::find 같은 멤버함수 아닌 일반 함수(템플릿). <algorithm> 헤더 필요

#### 6. 임시객체
* 이름 없는 객체 (unnamed object)
   * ex) Point (1, 2);
   * 수명: 자신을 선언한 문장의 끝
   * "임시 객체", "temporary" 라고도 함
* 특징
   * 임시객체는 등호의 왼쪽에 올 수 없음 (컴파일 에러)
   * 임시객체는 참조로 가리킬 수 없음 (컴파일 에러)
   * 임시객체는 const 참조로는 가리킬 수 있음
      * ex) const Point& r3 = Point(1, 2);
      * 이제, 임시 객체의 수명은 r3의 수명으로 연장

#### 그 외
* align
   * 컴파일러는 속도를 위해 4바이트 단위로 맞추기 위해 padding을 함(4바이트 단위가 속도가 빠름)
   * #pragma pack(1) // align을 1바이트로. padding 제거
   * 네트워크, 임베디드 시스템 등에서는 padding이 없는게 좋을 수 있음
* union: 공용체, 하나의 메모리를 여러 개 이름으로 접근
   * 보통 ip 관리할 때 많이 사용
* enum
   * 관련된 여러개의 상수를 만들 때 사용
   * 함수 안에도 만들 수 있고, 밖에도 만들 수 있음 (보통은 외부에 만듦)

```cpp
enum WEEKOFDAY { sun = 0, mon = 1, tue, wed, thu, fri, sat};
foo(WEEKOFDAY::mon);
```

### 앞으로 공부 방향
* 1. 기본 문법 공부
* 2. 객체 지향 디자인 - 어제 메뉴, 도형편집기, 다형성 등...
* 3. 복잡한 문법들 - template, 임시객체, 참조 반환 등..
* 4. STL 사용법
* 5. 다양한 테크닉 - C++ Idioms, CRTP 등..
* 6. 다양한 오픈 소스 읽기, STL 내부 구현 읽기(학습)
