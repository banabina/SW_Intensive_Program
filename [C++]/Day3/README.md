### C++ Day 3
#### 1. 정리
* C언어/C++에서 배웠던 내용 정리
#### 2. 선언과 구현의 분리
* static 멤버 함수는 선언과 구현으로 분리 시 **선언**에만 static을 표기해야함
* static 멤버 데이터의 외부 선언은 헤더가 아닌 **소스** 쪽에 포함되어야 함

#### 3. this 
* this: 현재 함수를 호출할 때 사용하는 객체 주소를 담는 키워드. 컴파일러가 아래 코드처럼 변경
* void set(int a, int b) // => void set(Point* this, int a, int b)
* 이름 충돌을 회피하기 위해
* this를 반환하면 멤버 함수를 연속적으로 호출 가능 (cout의 원리)
* static 멤버 함수는 객체없이 호출되므로 this를 사용할 수 없음

#### 4. 상수 멤버 함수
* 해당 멤버 함수 안에서는 멤버 데이터를 변경하지 않겠다고 컴파일러에게 알려주는 것
* _**상수 객체는 상수 멤버 함수만 호출 가능**_
* 상수 멤버 함수에서는 멤버변수 변경 안됨
* 객체의 상태를 변경하지 않는 모든 멤버 함수는 "반드시" 상수 멤버 함수로 해야함
* 동일이름의 함수를 상수 멤버 함수와 비상수 멤버함수로 동시에 제공가능
* 상수 멤버 함수 만들 때 const는 선언과 구현에 모두 표기해야 함

#### 5. 상속
* 기존 타입을 확장해서 새로운 타입을 설계 하는 것
* 접근 지정자 protected: 자신의 멤버 함수 + 파생 클래스 멤버 접근가능
* 파생 클래스에서는 기본적으로 베이스 클래스의 디폴트 생성자를 호출함
* 파생 클래스의 객체를 생성했을 때 베이스 클래스의 생성자가 바로 호출되는 게 아니라, 파생 클래스의 생성자가 먼저 호출되고 파생 클래스의 생성자의 초기화 리스트에서 베이스 클래스 생성자가 호출되는 것

#### 6. Upcasting
* 기반 클래스 포인터에 파생 클래스 타입 객체의 주소를 담을 수 있는 것 
    * Animal* p3 = &dog;
* 기반 클래스 포인터로는 기반 클래스 멤버만 접근 가능. 실제 가리키는 객체가 파생 클래스의 객체라도 접근 -> 캐스팅 사용해야됨 
  * p3->age = 10; // ok
  * p3->color = 20; // error
* 장점: 모든 동물 객체의 주소를 담을 수 있음

#### 7. 가상함수
* override : 기반 클래스 멤버 함수를 파생클래스가 다시 만드는 것
* 함수 바인딩
    * static binding: 컴파일 시간에 컴파일러가 함수 호출 결정 (빠르지만 비 논리적, C++, C# 기본 정책)
        * 컴파일 시간에는 p가 가리키는 객체가 어떤 객체인지 알 수 없음
        * 따라서, 컴파일러가 함수 호출을 결정하면 p의 타입 (Animal*)로 호출 결정 => Animal Cry1() 호출
    * dynamic binding (느리지만 논리적, java, swift, python 기본 정책, C++, C#의 가상함수)
        * 컴파일 시에 p가 가리키는 메모리를 조사하는 기계어 코드 생성
        * 실행할 때 메모리를 조사해서 함수 호출을 결정
* 가상함수(virtual function): dynamic binding 하라는 의미
* 가상함수 override 할 때 virtual은 붙여도 되고 없어도 됨 (붙이는 게 가독성이 좋음)
* override 키워드: 새로운 함수가 아니라 재정의 한다고 알리는 것
    * virtual void draw() override {};

#### 12. 가상소멸자
* 소멸자는 함수 호출이므로 static binding 또는 dynamic binding해야 함
* 모든 기반 클래스의 소멸자는 반드시 가상함수로 해야 함

#### 나중에
도형편집기, 추상클래스, 인터페이스, 가상함수 원리

#### 예제
* C언어로 GUI를 만들려면: 각 OS 제조사가 배포하는 함수를 사용해서 제작
* 구글 "C++ GUI library" 검색
* nana 설치 방법. nana 예시 많이 있음

#### 참고
github.com/webkit
* 브라우저의 정석이라고 불리는 소스. 사파리 브라우저 소스. 크롬 브라우저의 초기
* webkit/Source/WTF/wtf/Seconds.h 열어보자
인자로 const string&를 받는 함수에 문자열 literal을 보내면 임시 객체가 생성됨
* => 이는 성능 저하의 원인
* => explict 키워드로 이를 막을 수 있음
* 혹은 이러한 경우 임시객체가 생성되지 않고 포인터만 전달하게 하는 기법이 있음
